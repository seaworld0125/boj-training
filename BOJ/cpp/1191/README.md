# 1911

[링크](https://www.acmicpc.net/problem/1911)

| 난이도 | 정답률(\_%) | 시간 제한(초) | 푸는데 걸린 시간 |
|:---:|:--------:|:--------:|:---------:|
| 골드5  |    38    |    2     |   오래걸림    |

## 설계

### 1차 시도
일단 너무 오랜만에 풀어서 어려움이 있었다. 어떤 알고리즘이 필요하다기 보다는 그리디한 문제라는 것은 이해했다.
그러나 단순히 배열을 만들어두고 풀기에는 메모리 제한이 있었다. 그래서 1차 시도는 금세 관뒀다.

### 2차 시도
배열이 너무 클 수 밖에 없어서 비트가 필요할까? 라는 생각이 들었다. bitset으로 접근하면 메모리 조건은 맞출 수 있었다.
하지만 비트로 접근하면 for문 순회가 너무 잦았다. 시간 초과가 날 수 밖에 없어 접근 방식을 다시 바꿔야 했다.

### 3차 시도
조금 더 그리디하게... 단지 들어오는 웅덩이의 위치 값을 저장하고 cursor를 움직이면서 웅덩이의 범위에
몇 개의 널빤지가 필요한지만 계산할 수 있으면 됐다. 이를 구현했고 성공했다.

### 시간 복잡도
대략 O(N)이다. 최소 힙에서의 삽입(emplace)과 삭제(pop)는 O(log N)이 추가적으로 걸리긴 하지만 큰 차이가 없다.

### 공간 복잡도
O(N)

## 정리

3번 코드가 가장 최적화 되어 있다. 나눗셈을 할 때 올림을 해주지 않고 충분한 몫을 구하는 트릭...

예를 들어서
- p = 4, i = 2라면 p / i = 2이다.
- p = 3, i = 2라면 p / i = 1이다.

하지만 i가 널빤지의 넓이이고 p 만큼을 커버하는 널빤지의 개수를 구해야 한다면?

p = 3, i = 2일 때, p / i = 1이지만 2가 나오게끔 해야 한다.

이를 위해 p에 미리 i를 한번 더하면, 몫은 당연히 하나가 더 증가한다.
그런데 p가 i의 배수라면 다시 문제가 생긴다.

예를 들어서 p = 4, i = 2일 때, p / i = 2여야 하지만 p에 i를 더했기 때문에 
(p + i) / i = 3으로 몫이 1만큼 증가한다. 

따라서 여기에 1을 빼주면 p가 i의 배수가 아닐 때에도 성립한다.

결론적으로 p + i - 1 / i를 하면 올림을 하지 않고 충분한 몫을 구할 수 있다.


|  내 코드 (ms)   | 빠른 코드 (ms) |
|:------------:|:----------:|
| (1911-1) 156ms |    0ms     |
|  (1911-2) 4ms  |            |
|  (1911-3) 0ms  |            |