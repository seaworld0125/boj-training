    [문제]
    세로 i번째 사다리의 결과가 i가 되도록 만들고 싶다.
    만들 수 없거나 답이 3보다 크면 -1을 출력한다.

    가로선의 개수가 0일 수도 있는데 0인 경우 답은 무조건 0이다.

    [문제 접근]
    이 문제는 어디에 사다리를 두어야 하는지 알 수 없기 때문에
    완전 탐색으로 접근해야 한다.

    사다리를 놓았을 경우(놓을 수 있다면), 놓지 않았을 경우로 탐색이 나뉘며
    결과를 확인해서 원하는 결과를 도출한 경우에 답을 갱신하는
    작업이 이루어져야 한다.

    탐색은 행을 따라서 이루어져야 될 것으로 보이며, 각 세로 사다리에서 출발한 경로가
    어떤 세로 사다리를 타고 있는지 갱신하며 탐색해야 한다.
    이 작업은 세로선의 개수만큼 배열을 생성하고 초기에는 자신의 index로 초기화하자.

    즉 다음과 같은 재귀 함수를 정의할 수 있을 것 같다.

    return {성공 여부, 놓은 사다리의 개수}
    solve(vector<vector<int>>& bridgeMap, vector<int>& colState, int rowIndex);
    // 현재 가로선이 놓인 상태 저장 = bridgeMap
    // 현재 세로선의 결과들 = colState
    // 현재 탐색 중인 행 번호 = rowIndex

    기저 사례는 다음과 같다.
    - 행의 번호가 끝 번호 + 1일 때
    - 현재 놓은 사다리의 개수가 3개 초과일 때 

    [풀이를 진행하면서 수정된 문제 접근]
    --> 탐색은 행과 열을 따라서 이루어져야 될 것으로 보이며, 마지막 행에 도달한 경우
    사다리를 하나씩 확인하여 i번째 사다리가 i번째로 나오는지 검사하고 만약 그렇지 않은 경우
    바로 오답으로 판별하는 로직을 사용하면 전체 사다리 결과 검사 비용을 줄일 수 있다. 

    --> return void
    --> solve(int colIndex, int rowIndex, int bridgeCount);
    // 한 행에 여러 bridge가 들어갈 수 있기 때문에 열을 따라서도 완전 탐색이 필요하다
    // 현재 탐색 중인 열의 번호 = colIndex
    // 현재 탐색 중인 행의 번호 = rowIndex
    // 현재까지 놓은 다리의 개수 = bridgeCount

    기저 사례는 다음과 같다.
    - 행의 번호가 끝 번호 + 1일 때
    - 현재 놓은 사다리의 개수가 3개 초과일 때 
    + 현재 답이 구해놓은 답보다 클 때